{"version":3,"file":"popover-trigger-block/view.js","mappings":";;;;AAAA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,M","sources":["webpack://todo-list/./src/popover-trigger-block/view.ts"],"sourcesContent":["// import { store, getContext, getElement } from \"@wordpress/interactivity\";\n\n// type TOpenBy = \"click\" | \"focus\";\n\n// interface TContext {\n// \tmenuOpenedBy: {\n// \t\tclick: boolean;\n// \t\tfocus: boolean;\n// \t};\n// \tpreviousFocus: HTMLElement | null;\n// \tdropdownMenu: HTMLElement | null;\n// }\n\n// interface TState {\n// \tmenuOpenedBy: TContext[\"menuOpenedBy\"];\n// \tisMenuOpen: boolean;\n// }\n\n// const { state, actions } = store(\"ncmfse/current-user-avatar\", {\n// \tstate: {\n// \t\tget isMenuOpen() {\n// \t\t\t// The menu is opened if either `click` or `focus` is true.\n// \t\t\treturn Object.values(state.menuOpenedBy).filter(Boolean).length > 0;\n// \t\t},\n// \t\tget menuOpenedBy() {\n// \t\t\tconst context = getContext<TContext>();\n// \t\t\treturn context.menuOpenedBy;\n// \t\t},\n// \t} as TState,\n// \tactions: {\n// \t\ttoggleMenuOnClick() {\n// \t\t\tconst context = getContext<TContext>();\n// \t\t\tconst { ref } = getElement();\n\n// \t\t\t// Safari won't send focus to the clicked element, so we need to manually place it: https://bugs.webkit.org/show_bug.cgi?id=22261\n// \t\t\tif (window.document.activeElement !== ref) {\n// \t\t\t\tref?.focus();\n// \t\t\t}\n\n// \t\t\tif (state.menuOpenedBy.click || state.menuOpenedBy.focus) {\n// \t\t\t\tactions.closeMenu(\"click\");\n// \t\t\t\tactions.closeMenu(\"focus\");\n// \t\t\t} else {\n// \t\t\t\tcontext.previousFocus = ref;\n// \t\t\t\tactions.openMenu(\"click\");\n// \t\t\t}\n// \t\t},\n// \t\tcloseMenuOnClick() {\n// \t\t\tactions.closeMenu(\"click\");\n// \t\t\tactions.closeMenu(\"focus\");\n// \t\t},\n// \t\thandleMenuKeydown(event: KeyboardEvent) {\n// \t\t\tif (state.menuOpenedBy.click) {\n// \t\t\t\t// If Escape close the menu.\n// \t\t\t\tif (event?.key === \"Escape\") {\n// \t\t\t\t\tactions.closeMenu(\"click\");\n// \t\t\t\t\tactions.closeMenu(\"focus\");\n// \t\t\t\t}\n// \t\t\t}\n// \t\t},\n// \t\thandleMenuFocusout(event: FocusEvent) {\n// \t\t\tconst context = getContext<TContext>();\n// \t\t\tconst menuContainer = context.dropdownMenu?.querySelector(\n// \t\t\t\t\".wp-block-ncmfse-current-user-avatar-dropdown\",\n// \t\t\t);\n// \t\t\t// If focus is outside menu, and in the document, close menu\n// \t\t\t// event.target === The element losing focus\n// \t\t\t// event.relatedTarget === The element receiving focus (if any)\n// \t\t\t// When focusout is outside the document,\n// \t\t\t// `window.document.activeElement` doesn't change.\n\n// \t\t\t// The event.relatedTarget is null when something outside the navigation menu is clicked. This is only necessary for Safari.\n// \t\t\t// TODO: There is still an issue in Safari where clicking on the menu link closes the menu. We don't want this. The toggleMenuOnClick callback should handle this.\n// \t\t\tif (\n// \t\t\t\tevent.relatedTarget === null ||\n// \t\t\t\t(!menuContainer?.contains(event.relatedTarget) &&\n// \t\t\t\t\tevent.target !== window.document.activeElement)\n// \t\t\t) {\n// \t\t\t\tactions.closeMenu(\"click\");\n// \t\t\t\tactions.closeMenu(\"focus\");\n// \t\t\t}\n// \t\t},\n// \t\topenMenu(menuOpenedOn = \"click\") {\n// \t\t\tstate.menuOpenedBy[menuOpenedOn as TOpenBy] = true;\n// \t\t},\n// \t\tcloseMenu(menuClosedOn = \"click\") {\n// \t\t\tconst context = getContext<TContext>();\n// \t\t\tstate.menuOpenedBy[menuClosedOn as TOpenBy] = false;\n\n// \t\t\t// Reset the menu reference and button focus when closed.\n// \t\t\tif (!state.isMenuOpen) {\n// \t\t\t\tif (context.dropdownMenu?.contains(window.document.activeElement)) {\n// \t\t\t\t\tcontext.previousFocus?.focus();\n// \t\t\t\t}\n// \t\t\t\tcontext.previousFocus = null;\n// \t\t\t\tcontext.dropdownMenu = null;\n// \t\t\t}\n// \t\t},\n// \t},\n// \tcallbacks: {\n// \t\tonWatchMenu() {\n// \t\t\tconst context = getContext<TContext>();\n// \t\t\tconst { ref } = getElement();\n\n// \t\t\tconsole.log(\"onWatchMenu\", state.isMenuOpen);\n\n// \t\t\t// Set the menu reference when initialized.\n// \t\t\tif (state.isMenuOpen) {\n// \t\t\t\tcontext.dropdownMenu = ref;\n// \t\t\t}\n// \t\t},\n// \t},\n// });\n"],"names":[],"sourceRoot":""}